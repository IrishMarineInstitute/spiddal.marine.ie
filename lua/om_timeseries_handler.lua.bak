local helper = require("om_timeseries_helper")
local socket = require("socket")
local isodate = function(time)
    local t = os.date("!%Y-%m-%dT%T",time/1000)
    local s = string.format("%03d",time%1000)
    return t .. "." .. s .. "Z"
end

local makeTimeStamp =  function(dateString, mode)
    local pattern = "(%d+)%-(%d+)%-(%d+)%a(%d+)%:(%d+)%:([%d%.]+)([Z%p])(%d*)%:?(%d*)";
    local xyear, xmonth, xday, xhour, xminute, xseconds, xoffset, xoffsethour, xoffsetmin
    local monthLookup = {Jan = 1, Feb = 2, Mar = 3, Apr = 4, May = 5, Jun = 6, Jul = 7, Aug = 8, Sep = 9, Oct = 10, Nov = 11, Dec = 12}
    local convertedTimestamp
    local offset = 0
    if mode and mode == "ctime" then
        pattern = "%w+%s+(%w+)%s+(%d+)%s+(%d+)%:(%d+)%:(%d+)%s+(%w+)%s+(%d+)"
        local monthName, TZName
        monthName, xday, xhour, xminute, xseconds, TZName, xyear = string.match(dateString,pattern)
        xmonth = monthLookup[monthName]
        convertedTimestamp = os.time({year = xyear, month = xmonth,
        day = xday, hour = xhour, min = xminute, sec = xseconds})
    else
        xyear, xmonth, xday, xhour, xminute, xseconds, xoffset, xoffsethour, xoffsetmin = string.match(dateString,pattern)
        convertedTimestamp = os.time({year = xyear, month = xmonth,
        day = xday, hour = xhour, min = xminute, sec = xseconds})
        if xoffsetHour then
            offset = xoffsethour * 60 + xoffsetmin
            if xoffset == "-" then
                offset = offset * -1
            end
        end
    end
    -- todo support parsing millis?
    return (convertedTimestamp + offset) * 1000 + (xseconds % 1)* 1000
end
local splitEventTime =  function(eventtime,default_start,default_end)
    local pattern = "(.*)/(.*)"
    local a,b =  string.match(eventtime,pattern)
    if (a == nil or a == '') then
       a = default_start
    end
    if (b == nil or b == '') then
       b = default_end
    end
    return a,b
end
local pagetop = function(offering,property)
   local now = isodate(socket.gettime()*1000)
   ngx.say([===[{
  "id":"]===]..offering.id..[===[",
  "type" : "http://www.opengis.net/def/observationType/OGC-OM/2.0/OM_DiscreteTimeSeriesObservation",
  "observedProperty": {"href":"]===]..property.observedProperty..[===["},
  "procedure": {"href":"]===]..property.procedure..[===[http://www.opengis.net/def/waterml/2.0/processType/Sensor"},
  "featureOfInterest": {"href":"http://data.marine.ie/fluorometer/WetLabs-ECO-FLNTU/"},
  "resultTime": "]===]..now..[===[",
  "result": {
    "metadata": {
    },
    "defaultPointMetadata": {
      "interpolationType": {
        "href": "http://www.opengis.net/def/waterml/2.0/interpolationType/Continuous"
      },
      "quality": {
        "href": "http://www.opengis.net/def/waterml/2.0/quality/unchecked"
      },
      "uom" : "]===]..property.uom..[===["
    },
    "points": [
]===])
end
local pageend = function(start_time,end_time)
ngx.say([===[    ]
  },
  "phenomenonTime": { "begin":"]===]..start_time..[===[", "end":"]===]..end_time..[===[" }
}]===])
end
ngx.header["Content-Type"] = "text/plain"
local omts = require("om_timeseries_config")
if ngx.var.arg_ACCEPTVERSIONS ~= nil and 
   not omts:supportsVersion(ngx.var.arg_ACCEPTVERSIONS) then
     ngx.say("The requested ACCEPTVERSIONS is not supported") 
     ngx.exit(412)
end
if not omts:hasOffering(ngx.var.arg_OFFERING) then
     ngx.say("Requested OFFERING not found") 
     ngx.exit(404)
end
local offering = omts:offering(ngx.var.arg_OFFERING)
if ngx.var.arg_observedProperty == nil then
     ngx.say("observedProperty parameter is required. Allowable values are:") 
     for k in pairs(offering["properties"]) do ngx.say(k) end
     ngx.exit(412)
end
local observedProperty = offering["properties"][ngx.var.arg_observedProperty]

if observedProperty == nil then
     ngx.say("Requested observedProperty not found on the OFFERING. Allowable values are:") 
     for k in pairs(offering["properties"]) do ngx.say(k) end
     ngx.exit(404)
end


local cassandra = require "cassandra"

local session = cassandra.new()
session:set_timeout(1000) -- 1000ms timeout

local connected, err = session:connect("172.17.1.89",9042);
session:set_keyspace("das")

local now = socket.gettime()*1000
local an_hour_ago = now - (60*60*1000)
local defaults = { starttime = isodate(an_hour_ago), endtime = isodate(now) }

local params = setmetatable( ngx.req.get_uri_args(),{__index = defaults })

local query = offering["cassandra"]["cql"]

local output = function(d,property,sep)
  local comma = sep
  local start_time = nil
  local end_time = nil
  for i = 1, #d do
    local t = os.date("!%Y-%m-%dT%T",d[i].time/1000)
    local s = string.format("%03d",d[i].time%1000)
    local ts = t .. "." .. s .. "Z"
    ngx.say(comma..'{"time":{"instant":"'
            ..ts..'" },"value":'
            ..property.value(d[i])..'}')
    comma = ','
    start_time = start_time or ts
    end_time = ts
  end
  return { start_time = start_time, end_time = end_time }
end


local starttime,endtime = helper:splitEventTime(params.EVENTTIME,defaults.starttime, defaults.endtime)
local tsstart = helper:makeTimeStamp(starttime)
local tsend = helper:makeTimeStamp(endtime)
params.starttime = starttime
params.endtime = endtime

local query_params = {{type="timestamp", value=tsstart},
                      {type="timestamp", value=tsend}}

local rows, err = session:execute(query, query_params, {page_size = 1000}) 
if err then
  ngx.say(err.message)
  ngx.exit(500)
end
helper:pagetop(offering,observedProperty)
if rows then
  local result = output(rows,observedProperty,"")
  starttime = result["start_time"] or starttime
  endtime = result["end_time"] or endtime
  while rows.meta.has_more_pages do
    rows, err = session:execute(query, query_params, {paging_state = rows.meta.paging_state})
    if rows then
      result = output(rows,observedProperty,",")
      endtime = result["end_time"] or endtime
    end
  end
end

helper:pageend(starttime,endtime)
